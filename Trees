->level order traversal linewise 

//method I
public static void levelOrder(Node root){
    if(root==null){
        return ;
    }
    Queue<Node> mainq = new ArrayDeque<>();
    Queue<Node> helperq = new ArrayDeque<>();
    mainq.add(root);
    while(mainq.size()>0){
        Node curr = mainq.remove();
        System.out.print(curr.data);
        if(curr.left!=null){
            helperq.add(curr.left);
        }
        if(curr.right!=null){
            helperq.add(curr.right);
        }
        
        if(mainq.size()==0){
            mainq = helperq;
            helperq = new ArrayDeque<>();
            System.out.println();
        }
    }
}

//method II
public static void levelOrder(Node root){
    if(root==null){
        return ;
    }
    Queue<Node> qu = new ArrayDeque<>();
    qu.add(root);
    qu.add(null);
    while(qu.size()>1){
        Node curr = qu.remove();
        if(curr!=null){
            System.out.print(curr.data);
            if(curr.left!=null){
                qu.add(curr.left);
            }
            if(curr.right!=null){
                qu.add(curr.right);
            }
        }
        else{
            System.out.println();
            qu.add(null);
        }
    }
}

//method III
public static void levelOrder(Node root){
    if(root==null){
        return ;
    }
    Queue<Node> qu = new ArrayDeque<>();
    qu.add(root);
    while(qu.size()>0){
        int count = qu.size();
        for(int i=0;i<count;i++){
            Node curr = qu.remove();
            System.out.print(curr.data+" ");
            if(curr.left!=null){
                qu.add(curr.left);
            }
            if(curr.right!=null){
                qu.add(curr.right);
            }
        }
        System.out.println();
    }
    return ;
}

-> level Order traversal in spiral form

public static void levelOrder(Node root){
    Stack<Node> mains = new Stack<>();
    Stack<Node> helpers = new Stack<>();
    mains.push(root);
    int level = 0;
    while(mains.size()>0){
        Node curr = mains.pop();
        if(level%2==0){
            System.out.print(curr.data);
            if(curr.left!=null){
                helpers.push(curr.left);
            }
            if(curr.right!=null){
                helpers.push(curr.right);
            }
        }
        else{
            System.out.print(curr.data);
            if(curr.right!=null){
                helpers.push(curr.right);
            }
            if(curr.left!=null){
                helpers.push(curr.left);
            }
        }
        
        if(mains.size()==0){
            System.out.println();
            level++;
            Stack<Node> temp = mains;
            mains = helpers;
            helpers = temp;
        }
    }
}

->left view of binary tree

public static void leftview(Node root){
    if(root==null){
        return ;
    }
    Queue<Node> qu = new ArrayDeque<>();
    qu.add(root);
    while(qu.size()>0){
        int count = qu.size();
        for(int i=0;i<count;i++){
            Node curr = qu.remove();
            if(i==0){
                System.out.print(curr.data);
            }
            if(curr.left!=null){
                qu.add(curr.left);
            }
            if(curr.right!=null){
                qu.add(curr.right);
            }
        }
        System.out.println();
    }
}

->right view of binary tree

public static void rightview(Node root){
    if(root==null){
        return ;
    }
    Queue<Node> qu = new ArrayDeque<>();
    qu.add(root);
    while(qu.size()>0){
        int count = qu.size();
        for(int i=0;i<count;i++){
            Node curr = qu.remove();
            if(i==count-1){
                System.out.print(curr.data);
            }
            if(curr.left!=null){
                qu.add(curr.left);
            }
            if(curr.right!=null){
                qu.add(curr.right);
            }
        }
        System.out.println();
    }
    return ;
}

->height of binary tree

public static int height(Node root){
    if(root==null){
        return -1;
    }
    int lh = height(root.left);
    int rh = height(root.right);
    return Math.max(lh,rh)+1;
}

->diameter of binary tree

//method I
public static int diameter(Node root){
    if(root==null){
        return 0;
    }
    int d1 = diameter(root.left);
    int d2 = diameter(root.right);
    int d3 = 2 + height(root.left) + height(root.right);
    return Math.max(d3,Math.max(d1,d2));
}

//method II
static int dia ;
public static int heightfordiameter(Node root){
    if(root==null){
        return -1;
    }
    int lh = heightfordiameter(root.left);
    int rh = heightfordiameter(root.right);
    dia = Math.max(lh+rh+2,dia);
    return Math.max(lh,rh)+1;
}

//method III
static class DiaPair{
    int dia;
    int ht;
    
    public DiaPair(){
        this.dia = 0;
        this.ht = -1;
    }
}

public static DiaPair diameter(Node root){
    if(root==null){
        return new DiaPair();
    }
    DiaPair lres = diameter(root.left);
    DiaPair rres = diameter(root.right);
    DiaPair mres = new DiaPair();
    mres.ht = Math.max(lres.ht,rres.ht)+1;
    mres.dia = Math.max(lres.ht+rres.ht+2,Math.max(lres.dia,rres.dia));
    return mres;
}

->LCA of a BST

//method I
public static ArrayList<Integer> nodetorootpath(Node root,int val){
    if(root==null){
        return new ArrayList<>();
    }
    if(root.data==val){
        ArrayList<Integer> bres = new ArrayList<>();
        bres.add("");
        return bres;
    }
    ArrayList<Integer> lres = nodetorootpath(root.left,n);
    if(lres.size()>0){
        lres.add(root);
        return lres;
    }
    ArrayList<Integer> rres = nodetorootpath(root.right,n);
    if(rres.size()>0){
        rres.add(root);
        return rres;
    }
    return new ArrayList<>();
}

public static int LCA(Node root,int n1,int n2){
    ArrayList<Integer> p1 = nodetorootpath(root,n1);
    ArrayList<Integer> p2 = nodetorootpath(root,n2);
    int i = p1.size()-1;
    int j = p2.size()-1;
    int res = -1;
    while(i>=0 && j>=0 && p1.get(i)==p2.get(j)){
        res = p2.get(j);
        i--;
        j--;
    }
    return res;
}

//method II
public static Node LCA(Node root,int n1,int n2){
    if(root==null){
        return null;
    }
    if(root.key==n1 || root.key==n2){
        return root;
    }
    Node lres = LCA(root.left,n1,n2);
    Node rres = LCA(root.right,n1,n2);
    if(lres!=null && rres!=null){
        return root;
    }
    if(lres!=null){
        return lres;
    }
    else{
        return rres;
    }
}

->construct binary tree from preorder and inorder

//Method I
public TreeNode buildTree(int[] preorder, int[] inorder) {
    preindex = 0;
    TreeNode root = construct(preorder,inorder,0,inorder.length-1);
    return root;
}

static int preindex;

public TreeNode construct(int[] preorder,int[] inorder,int is,int ie){
    if(is>ie){
        return null;
    }
    int indx = is;
    
    TreeNode root = new TreeNode(preorder[preindex++]);
    for(int i=is;i<=ie;i++){
        if(root.val==inorder[i]){
            indx = i;
            break;
        }
    }
    root.left = construct(preorder,inorder,is,indx-1);
    root.right = construct(preorder,inorder,indx+1,ie);
    return root;
}

//Method II
public static Node createtree(int[] in,int[] pre){
    preidx = 0;
    HashMap<Integer,Integer> mp = new HashMap<>();
    for(int i=0;i<in.length;i++){
        mp.put(in[i],i);
    }
    Node root = construct(in,pre,mp,0,inorder.length-1);
    return root;
    
}

static int preidx;

public static Node construct(int[] in,int[] pre,HashMap<Integer,Integer> mp,int is,int ie){
    if(is>ie){
        return null;
    }
    Node root = new Node(pre[preidx++]);
    int idx = mp.get(root.val);
    root.left = construct(in,pre,mp,is,idx-1);
    root.right = construct(in,pre,mp,idx+1,ie);
    return root;
}

->check for BST

//method I
public static boolean isBST(Node root,int minval,int maxval){
    if(root==null){
        return true;
    }
    return (root.data>minval)&&(root.data<maxval)&&
    (isBST(root.left,minval,root.data))&&
    (isBST(root.right,root.data,maxval));
}

//method II
static int prev ; //initialize prev with Integer.MIN_VALUE
public static boolean isBST(Node root){
    if(root==null){
        return true;
    }
    if(isBST(root.left)==false){
        return false;
    }
    if(root.key<=prev){
        return false;
    }
    prev = root.key;
    return isBST(root.right);
}
