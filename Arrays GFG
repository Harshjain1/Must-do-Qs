->spirally traversing a matrix

public static void traverse(int[][] arr){
    int n = arr.length;
    int m = arr[0].length;
    int rmin=0,rmax=n-1;
    int cmin=0,cmax=m-1;
    int tel=n*m;
    while(tel>0){
        for(int i=rmin;i<=rmax && tel>0;i++){
            System.out.println(arr[i][cmin]);
            tel--;
        }
        cmin++;
        for(int j=cmin;j<=cmax && tel>0;j++){
            System.out.println(arr[rmax][j]);
            tel--;
        }
        rmax--;
        for(int i=rmax;i>=rmin && tel>0;i--){
            System.out.println(arr[i][cmax]);
            tel--;
        }
        cmax--;
        for(int j=cmax;j>=cmin && tel>0;j--){
            System.out.println(arr[rmin][j]);
            tel--;
        }
        rmin++;
    }
    return ;
}

->sort an array of 0's,1's and 2's

//Method I apply sorting 

//Method II count freq of 0,1 and 2 and fill accordingly

//Method III

public void sortColors(int[] nums){
    int low=0,mid=0;
    int high = nums.length-1;
    while(mid<=high){
        if(nums[mid]==0){
            swap(nums,low,mid);
            low++;
            mid++;
        }
        else if(nums[mid]==1){
            mid++;
        }
        else{
            swap(nums,mid,high);
            high--;
        }
    }
}

->trapping rain water

public static int getWater(int arr[], int n){
	int res = 0;

	int lMax[] = new int[n];
	int rMax[] = new int[n];

	lMax[0] = arr[0];
	for(int i = 1; i < n; i++)
		lMax[i] = Math.max(arr[i], lMax[i - 1]);


	rMax[n - 1] = arr[n - 1];
	for(int i = n - 2; i >= 0; i--)
		rMax[i] = Math.max(arr[i], rMax[i + 1]);

	for(int i = 1; i < n - 1; i++)
		res = res + (Math.min(lMax[i], rMax[i]) - arr[i]);
	
	return res;
}

->equilibrium point

public static int eqbpoint(int[] arr){
    int sum = 0;
    for(int i=0;i<arr.length;i++){
        sum += arr[i];
    }
    int lsum = 0;
    for(int i=0;i<arr.length;i++){
        if(lsum == sum-arr[i]){
            return i;
        }
        lsum += arr[i];
        sum -= arr[i];
    }
    return -1;
}

->kadane's algorithm (Maximum subarray sum)

public static int maximumsubarray(int[] arr){
    int res = arr[0];
    int maxending = arr[0];
    for(int i=1;i<arr.length;i++){
        //maxending is maximum sum ending with current element
        maxending = Math.max(maxending+arr[i],arr[i]); 
        res = Math.max(res,maxending);
    }
    return res;
}

->leaders in an array

public static void leaders(int[] arr){
    int curr_ldr = arr[arr.length-1];
    System.out.print(curr_ldr);
    for(int i=arr.length-2;i>=0;i--){
        if(arr[i]>curr_ldr){
            curr_ldr = arr[i];
            System.out.print(curr_ldr);
        }
    }
    return ;
}

->missing numbers in an array

public static int MissingNumber(int[] arr,int n){
   int res = 0;
   for(int i=0;i<arr.length;i++){
       res = res^arr[i];
   }
   for(int i=1;i<=n;i++){
       res = res^i;
   }
   return res;
}

->subarray with given sum

int subArraySum(int[] arr,int sum){ 
int curr_sum = arr[0], start = 0; 
int n = arr.length;
// Pick a starting point 
for (int i = 1; i <= n; i++){ 
	// If curr_sum exceeds the sum, then remove the starting elements 
	while (curr_sum > sum && start < i-1){ 
		curr_sum = curr_sum - arr[start]; 
		start++; 
	} 
	// If curr_sum becomes equal to sum, then return true 
	if (curr_sum == sum){ 
		int p = i-1; 
		System.out.println("Sum found between indexes " + start + " and " + p); 
		return 1; 
	} 
	// Add this element to curr_sum 
	if (i < n) 
	curr_sum = curr_sum + arr[i];
}
System.out.print("no subarray found");
return 0;
}

->element with left side smaller and right side greater

public static void leftside(int[] arr){
    int n = arr.length;
    int[] lmax = new int[n];
    int[] rmin = new int[n];
    lmax[0] = arr[0];
    rmax[n-1] = arr[n-1];
    for(int i=1;i<n;i++){
        lmax[i] = Math.max(lmax[i-1],arr[i-1]);
    }
    for(int i=n-2;i>=0;i--){
        rmax[i] = Math.min(rmax[i+1],arr[i+1]);
    }
    for(int i=0;i<n;i++){
        if(lmax[i]<=arr[i] && rmax[i]>=arr[i]){
            System.out.print(arr[i]);
        }
    }
    return ;
}

->find the duplicate number

//Method I
//sort the array and compare adjacent elements 
//when two adjacent elements are same 
//that will be the result
time complexity -> O(nlogn)

//Method II
public static int duplicatenumber(int[] arr){
    int slow = arr[0];
    int fast = arr[0];
    slow = arr[slow];
    fast = arr[arr[fast]];
    while(slow!=fast){
        slow = arr[slow];
        fast = arr[arr[fast]];
    }
    fast = arr[0];
    while(slow!=fast){
        slow = arr[slow];
        fast = arr[arr[fast]];
    }
    return slow;
}

->missing and repeating number

//Method I
//make a frequency array equal size
//put elements in the array
//again traverse freq array and check the freq of all 
//elements ,if freq is 0 that is missing element
//if freq is 2 that is repeating element


//method II
public static void missingandrepeating(int[] arr){
    int xor1 = 0;
    int n = arr.length;
    for(int i=1;i<=n;i++){
        xor1 = xor1^i;
    }
    for(int i=0;i<n;i++){
        xor1 = xor1^arr[i];
    }
    int res = xor1&~(xor1-1);
    int num1 = 0;
    int num2 = 0;
    for(int i=0;i<n;i++){
        if(arr[i]&&res){
            num1 = num1^arr[i];
        }
        else{
            num2 = num2^arr[i];
        }
    }
    for(int i=1;i<=n;i++){
        if(i&&res){
            num1 = num1^i;
        }
        else{
            num2 = num2^i;
        }
    }
    System.out.print(num1 +" "+num2);
}

->merge two sorted array 

//method I
//take a array of size n1 + n2
//sort the array and fill
//the array1 and array2 

//method II
public static void merge(int[] X,int[] Y){
    int m = X.length;
    int n = Y.length;
    for(int i=0;i<m;i++){
        if(X[i]>Y[0]){
            int temp = X[i];
            X[i] = Y[0];
            Y[0] = temp;
            
            int first = Y[0];
            for(int k=1;k<n && Y[k]<first;k++){
                Y[k-1] = Y[k];
            }
            Y[k-1] = first;
        }
    }
}

->count triplets
->number of pairs
->inversion of array
->convert array into zig zag fashion
->last index of 1
->largest number formed from an array
->stock buy and sell
->pythagorean triplet
->chocolate distribution problem
->minimum platforms
->reverse array in groups
->kth smallest element
->rearrange arrays alternatively
